###############################################################################
 _        _______  ______   _______   _________ _______  _ 
( (    /|(  ___  )(  __  \ (  ____ \  \__    _/(  ____ \( )
|  \  ( || (   ) || (  \  )| (    \/     )  (  | (    \/| |
|   \ | || |   | || |   ) || (__         |  |  | (_____ | |
| (\ \) || |   | || |   | ||  __)        |  |  (_____  )| |
| | \   || |   | || |   ) || (           |  |        ) |(_)
| )  \  || (___) || (__/  )| (____/\  |\_)  )  /\____) | _ 
|/    )_)(_______)(______/ (_______/  (____/   \_______)(_)
                                                           
################################################################################

Course Details : Node.js Full Course for Beginners 
Tutor :  Dave grey, Youtube 
Published  :  December 3 2021 

#################################################################################

+-----------------------+
|    Introduction       |
+-----------------------+  

In this course, we would be going via topics than going through deep 
concepts. By this way, we will have subject knowledge on what is being 
learnt 

+-----------------------+
|    How node differs   |
+-----------------------+

- Runs in the server 
- This means the server will have a runtime environment. 
- Console would be node console. It would be in terminal / command prompt 
        console.log("Hello World")


+------------------------------------+
|    Global object vs Window Object  |
+------------------------------------+

- Global object is the runtime environment. Window object is the browser. 

        console.log("Hello World)
        console.log(global)

Hello World!
<ref *1> Object [global] {
  global: [Circular *1],
  clearInterval: [Function: clearInterval],
  clearTimeout: [Function: clearTimeout],
  setInterval: [Function: setInterval],
  setTimeout: [Function: setTimeout] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  },
  queueMicrotask: [Function: queueMicrotask],
  performance: Performance {
    nodeTiming: PerformanceNodeTiming {
      name: 'node',
      entryType: 'node',
      startTime: 0,
      duration: 400.14816600084305,
      nodeStart: 120.28114499896765,
      v8Start: 175.724365003407,
      bootstrapComplete: 359.1304709985852,
      environment: 250.2307410016656,
      loopStart: -1,
      loopExit: -1,
      idleTime: 0
    },
    timeOrigin: 1644758615694.229
  },
  clearImmediate: [Function: clearImmediate],
  setImmediate: [Function: setImmediate] {
    [Symbol(nodejs.util.promisify.custom)]: [Getter]
  }
}

+-------------------------+
| Common JS Modules - OS  |
+-------------------------+

- Common core modules are present in Node than JS 

//Common JS Modules

const os = require("os");
const path = require("path");


//Prints the linux version of the os
console.log(os.type());

//Prints the version of the operating system Again linux version
console.log(os.version());

//Prints the location of home directory
console.log(os.homedir());

//prints current directory Name
console.log(__dirname);

//prints the file name
console.log(__filename);

//Print the entire dir and path
console.log(path.dirname(__filename)); //Super useful!

//File base name. Remember prints only the file namer
console.log(path.basename(__filename));

//print the the file extension name
console.log(path.extname(__filename)); //Super useful

//Lets check what this is doing...
console.log(path.parse(__filename)); //Amazing. Throws and object full of the meta data

+-------------------------+
|    Custom Modulation    | 
+-------------------------+

math.js

const add = (a, b) => a + b;
const sub = (a, b) => a - b;
const mul = (a, b) => a * b;
const div = (a, b) => a / b;

//Object destructured export
module.exports = { add, sub, mul, div };

//you could also export like export.add = (a, b) => a + b

const math = require("./math");
console.log(math.add(2, 4));

//Destructured import

const { sub } = require("./math");
console.log(sub(2, 6));

Topics revised were 

- Node runtime introduction 
- Node vs vanilla javascript 
- gloab object vs window object 
- using common js modules , os and path modules
- exporting code via js files 
- custom modulations 

+------------------------------------------+
|    Create, Read and Update files in JS   | 
+------------------------------------------+

- the filesystem modules 


const fs = require("fs");
const path = require("path");
//Reading file

// Remember important notes when we wrote this function
// You could pass a utf-8 parameter to encode the data directly without converting to string
// Always the data read will be a buffer string!!!! <Buffer 48 69 2c 20 74 68 69 73 20 69 73 20 53 69 76 61>
// Unless you convert it, it aint going to pretty print it!!

//READING A FILE
fs.readFile(path.join(__dirname, "starter.txt"), "utf-8", (err, data) => {
  if (err) throw err;
  console.log(data);
});

console.log("Hello");

//WRITING A FILE
fs.writeFile(
  path.join(__dirname, "reply.txt"),
  "Writing text using node js is fun",
  (err, data) => {
    if (err) throw err;
    console.log("Operation Complete Write complete");
    //Appending
    fs.appendFile(
      path.join(__dirname, "reply.txt"),
      " Appended text",
      (err) => {
        if (err) throw err;
        console.log("Append Complete");
        //Renaming

        fs.rename(
          path.join(__dirname, "reply.txt"),
          path.join(__dirname, "new_reply.txt"),

          (err) => {
            if (err) throw err;
            console.log("Rename Complete");
          }
        );
      }
    );
  }
);

//APPENDING A FILE

//exit on uncaught errors
//process is an inbuilt module in node which helps in logging errors
process.on("uncaughtException", (err) => {
  console.error(`There was an uncaught error:${err}`);
  process.exit(1); //exit in 1 second?
});


There were 4 different ways in which we could read and write files 
- first would be the direct function call 
- the second would be a nested function call 
- the third would be asyc and await function to read, delete, append, unlink files etc 
- the fourth would be streaming input and output streaming the files 

In all these cases, streaming the files was the best way to deal with file management in 
node js. Rest all is repeatitive monotonous syntaxes 

+-----------------------------+
|    Node Package Manager...  | 
+-----------------------------+

difference between common js modules vs npm is that... 

npm was created by 3rd party coders 
npm also checks the standards of the code 
npm has almost all the code you wish to re-use 

